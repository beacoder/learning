learning emacs lisp

1.car cdr cons nth nthcdr butlast
cons: the cons function constructs lists
exp:  (cons 'rose '(violet daisy buttercup))  ⇒ (rose violet daisy buttercup)

car:  return the first item in the list
exp:  (car '(rose violet daisy buttercup))  ⇒  rose

cdr:  return the second to last elements
exp:  (cdr '(rose violet daisy buttercup))  ⇒  (violet daisy buttercup)  

nth:  return the nth item in the list
exp:  (nth 1 '(rose violet daisy buttercup))  ⇒ violet

nthcdr: return the nth to last elements
exp:  (nthcdr 1 '(rose violet daisy buttercup)) ⇒ (violet daisy buttercup)

butlast:  without the last n elements
exp:  (butlast '(rose violet daisy buttercup) 2)  ⇒  (rose violet)

2.interactive
description: the purpose of (interactive …) is to makes your function callable as interactive command,
which can be called by execute-extended-command "M-x".
it also provides a method for taking user input and feed to your function's arguments.

3.quote
description: return the argument, without evaluating it.
exp:  `(quote x)' ⇒ `x'

4.evaluate expression
description: means executing the expression and returning the evaluated result.
exp:  eval-buffer eval-region eval-minibuffer.
rules:  
4.1 self-evaluating:  any form that is not a list or symbol will evaluate to themselves.
4.2 symbol: symbol is treated as a variable and will evaluate to the variable's value.
4.3 list: if the first element of the list is
          a symbol ⇒  uses the symbol's function cell contents, then call the function.
          a function object ⇒  evaluate the remaining elements of the list as actual argument,                       
                                then call the function with this list of arguments.
          a macro object  ⇒  expand the macro to some kind of other form.

5.elt aset
elt:  return element of SEQUENCE at index N.
exp:  (elt (vector 3 4 5) 0)  ⇒ 3.

aset: store element into ARRAY at index.
exp:  (setq v [3 4 5])  (aset v 0 "b")  ⇒ v = ["b" 4 5]

6.mapcar mapc
mapcar: apply FUNCTION to each element of SEQUENCE, and make a list of the results.
exp:  (mapcar '1+ [3 4 5] ) ⇒ (4 5 6)

mapc: apply FUNCTION to each element of SEQUENCE, and return the unchanged SEQUENCE.
exp:  (mapc '1+ [3 4 5] ) ⇒ [3 4 5]

7.pop nbutlast setcar setcdr
pop:  remove first element from the list and returns the removed element.
nbutlast: remove last n elements from the list and returns the new value of the list.
setcar: replaces the first element in the list and returns the replacing element.
setcdr: replaces the rest of elements in the list and returns the replacing element.

8.alist & hash table
alist:  when a list has the form ((key1 . value1) (key2 . value2) (key3 . value3)), 
        it is called an association list, or alist for short, 
        it is used to records a mapping from keys to values.
exp:  
((red . "ff000") (green . "00ff00") (blue . "000ff"))
((red "ff0000") (green "00ff00O") (blue "000ff")) 
(assoc 'green '((red . "ff000") (green . "00ff00") (blue . "000ff"))) ⇒ (green . "00ff00")

hash table: a very fast kind of lookup table.

9.thing-at-point & bounds-of-thing-at-point
thing-at-point: return the thing at point. 
thing should be a symbol specifying a type of syntactic entity,
including `symbol', `list', `sexp', `defun',`filename', `url', `email', `word', 
`sentence', `whitespace', `line', `number', and `page'.
exp:  (thing-at-point 'word)

bounds-of-thing-at-point: return the start and end buffer locations for the thing at point.
exp:  (bounds-of-thing-at-point 'word)

10.eq equal
eq:  tests whether its arguments are the same object.
equal:  tests whether two objects have the same structure and contents.

11.control structures
11.1 (if COND THEN ELSE...) ⇒ If COND yields non-nil, do THEN, else do ELSE...

11.2 (cond CLAUSES...) ⇒ try each clause until one succeeds.
exp:  
(cond ((eq 'a 'b) 'first) ((atom 'a) 'second)) ⇒ second

11.3 (when COND BODY...) ⇒ If COND yields non-nil, do BODY, else return nil.

11.4 (unless COND BODY...) ⇒ If COND yields nil, do BODY, else return nil.

11.5 (while TEST BODY...) ⇒ If TEST yields non-nil, eval BODY... and repeat.

11.6 (dolist (VAR LIST [RESULT]) BODY...)
     Loop over a list.
     Evaluate BODY with VAR bound to each car from LIST, in turn.
exp:
(dolist (x '(1 2 3)) (insert (number-to-string x))) ⇒ "123"
     
11.7 (dotimes (VAR COUNT [RESULT]) BODY...)
     Loop a certain number of times.
     Evaluate BODY with VAR bound to successive integers running from 0, inclusive, to COUNT, exclusive. 
exp:
(dotimes (x 3 "return value") (insert (number-to-string x))) ⇒ 012"return value"

11.8 catch and throw
     (catch TAG BODY...) ⇒ catch establishes a return point for the throw function.
     (throw TAG VALUE) ⇒ The purpose of throw is to return from a return point previously established with catch.
exp:
(catch 'hack (throw 'hack 'yes)) ⇒ yes
     
12.
