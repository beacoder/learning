learning Python

0.Philosophy
Python where we can, C++ where we must.

1.Data structures
list,  tuple, set,   dict...

[1,2], (1,2), {1,2}, {'A':1,'B':2}

2.For loop
for ... in ... :
  ...
[else :]
  ...

Under the hood:

for i in seq:
  do_something_to(i)

* is equivalent to *

fetch = iter(seq)
while True:
  try:
    i = fetch.next()
  except StopIteration:
    break
  do_something_to(i)

3.List comprehension
[expr for ... in ...]
[expr for ... in ... if cond_expr]

e.g: calculate the length of the maximum line of one file.
return max([len(x.strip()) for x in open('/etc/motd')])

4.Generator expression
(expr for ... in ...)
(expr for ... in ... if cond_expr)

5.With statement
Similar to RAII in C++

with context_expr [as var]:
  ...

6.Range
range(end)
range(start, end)
range(start, end, step)

7.Function decorator
@deco
def func():
  pass

* is equivalent to *

func = deco(func)

8.Generator
Function which returns a generator iterator by calling yield.

def generator()
  yield 1
  yield 2
  pass

9.Static function and Class function
@staticmethod
def f():
  pass

@classmethod
def f(cls):
  pass

10.Regexp module
import re
re.compile, re.match, re.search

11.Iterator
Objects with next() method.

12.Help functions
dir  -> List functions/variables/classes etc in current scope.
help -> Show help information for functions/variables/classes etc.

13.Logging
import logging

logging.basicConfig(filename = "/path/to/log",
                    level=level,
                    format='%(asctime)s %(levelname)-8s %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S')
logging.debug("This is a debug message.")
logging.info("This is a info message.")

14.LRU cache (least recently used cache)
Decorator to wrap a function with a memoizing callable that saves up to the maxsize most recent calls.

from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

15.UnitTest
Unit Test is crucial if you don't want your application break on production environment.

import unittest
class Tests(unittest.TestCase):
    pass
TestCase.assertEqual, TestCase.assertRaises, TestCase.assertTrue...

python -m unittest

16.Exceptions
try:
...
except ... as err:
...
else:
...
finally:
...

17.Most useful modules from standard library
os, sys, datetime, math, random, re, json, socket, struct, logging.
collections, functools, selectors, threading.

18.Why use OOP and Design Patterns ?
When project gets bigger, larger and complicated.
OOP and Design Pattern help to manage the complexity.

OOP includes: Encapsulation, Inheritance, Polymorphism.
Encapsulate data/code into Class  => Hide complexity.
Inheritance, Polymorphism         => Reuse code.

Design Pattern                    => Separation of concerns.

19.Architecture Pattern, Design Pattern, Idioms.

Model-View-Controller (Architecture):
Define three interfaces:      IModel, IView, IController.
Define three implementations: Model,  View,  Controller.

Encapsulate CoreData        into Model.
Encapsulate UI/Input/Output into View.
Encapsulate BusinessLogic   into Controller.

Design Patterns within M-V-C:
Observer  Pattern: Model <-> Controller, Model <-> View
Strategy  Pattern: View  <-> Controller
Composite Pattern: View

Design Patterns describe RELATIONSHIPS and INTERACTIONS between components.
Idioms describe how to implement particular aspects of components.

Scope/Level: Architecture Pattern > Design Pattern > Idioms
