learning Python

0.Philosophy
Python where we can, C++ where we must.

1.For loop
for ... in ... :
  ...
[else :]
  ...

Under the hood:

for i in seq:
  do_something_to(i)

* is equivalent to *

fetch = iter(seq)
while True:
  try:
    i = fetch.next()
  except StopIteration:
    break
  do_something_to(i)

2.List comprehension
[expr for ... in ...]
[expr for ... in ... if cond_expr]

e.g: calculate the length of the maximum line of one file.
return max([len(x.strip()) for x in open('/etc/motd')])

3.Generator expression
(expr for ... in ...)
(expr for ... in ... if cond_expr)

4.With statement
Similar to RAII in C++

with context_expr [as var]:
  ...

5.Range/Xrange
range(end)
range(start, end)
range(start, end, step)

6.Function decorator
@deco
def func():
  pass

* is equivalent to *

func = deco(func)

7.Generator
Function which returns a generator iterator by calling yield.

def generator()
  yield 1
  yield 2
  pass

8.Static function and Class function
@staticmethod
def f():
  pass

@classmethod
def f(cls):
  pass

9.Regexp module
import re
re.compile, re.match, re.search

10.Iterator
Objects with next() method.

11.Help functions
dir  -> List functions/variables/classes etc in current scope.
help -> Show help information for functions/variables/classes etc.

12.Logging
import logging

LOG_FORMAT = "%(asctime)s %(levelname)s - %(message)s"
logging.basicConfig(filename = "/path/to/log",
                    level = logging.DEBUG,
                    format = LOG_FORMAT)
logger = logging.getLogger()
logger.debug("This is a debug message.")
logger.info("This is a info message.")

13.LRU cache (least recently used cache)
Decorator to wrap a function with a memoizing callable that saves up to the maxsize most recent calls.

from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

14.Why use OOP and Design Patterns ?
When project gets bigger, larger and complicated.
OOP and Design Pattern help to manage the complexity.

OOP includes: Encapsulation, Inheritance, Polymorphism.
Encapsulate data/code into Class  => Hide complexity.
Inheritance, Polymorphism         => Reuse code.

Design Pattern                    => Separation of concerns.

15.Architecture Pattern, Design Pattern, Idioms.

Model-View-Controller (Architecture):
Define three interfaces:      IModel, IView, IController.
Define three implementations: Model,  View,  Controller.

Encapsulate CoreData        into Model.
Encapsulate UI/Input/Output into View.
Encapsulate BusinessLogic   into Controller.

Design Patterns within M-V-C:
Observer  Pattern: Model <-> Controller, Model <-> View
Strategy  Pattern: View  <-> Controller
Composite Pattern: View

Design Patterns describe RELATIONSHIPS and INTERACTIONS between components.
Idioms describe how to implement particular aspects of components.

Scope/Level: Architecture Pattern > Design Pattern > Idioms
