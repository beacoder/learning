learning Python

1.For loop
for ... in ... :
  ...
[else :]
  ...

Under the hood:

for i in seq:
  do_something_to(i)

* is equivalent to *

fetch = iter(seq)
while True:
  try:
    i = fetch.next()
  except StopIteration:
    break
  do_something_to(i)
         
2.List comprehension
[expr for ... in ...]
[expr for ... in ... if cond_expr]

e.g: calculate the length of the maximum line of one file. 
return max([len(x.strip()) for x in open('/etc/motd')])

3.Generator expression
(expr for ... in ...)
(expr for ... in ... if cond_expr)

4.With statement
with context_expr [as var]:
  ...
  
5.Range/Xrange
range(end)
range(start, end)
range(start, end, step)

6.Function decorator
@deco
def func():
  pass

* is equivalent to *

func = deco(func)

7.Generator
def generator()
  yield 1
  yield 2
  pass
  
8.Static function and Class function
@staticmethod
def f():
  pass

@classmethod
def f(cls):
  pass

9.Regexp module
import re
re.compile, re.match, re.search

10.Iterator
Objects with next() method.

11.Most useful modules from standard library
Common: re, time, datetime, decimal, math
Shell:  os, sys, argparse, logging, subprocess, threading
File:   shutil, tempfile, glob, fnmatch
DB:     sqlite, json
Web:    urllib, urllib2, requests

12.Why use OOP ?
When project gets bigger, larger and complicated.
OOP helps to manage the complexity.

OOP includes: Encapsulation, Inheritance, Polymorphism.
Encapsulate data/code into Class  => Hide complexity.
Inheritance, Polymorphism         => Reuse code.
