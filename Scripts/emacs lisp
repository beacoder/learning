learning emacs lisp

0.symbol
description: each lisp symbol has the following “cells” to store things: {name, value, function, property list}.
name                ⇒ a string, typically the same as the symbol.
value               ⇒ stores the symbol's value, typically when the symbol is used as variable.
function            ⇒ stores function definition object or lisp macros.
property list       ⇒ typically hold a list of name/value pairs, used for syntax coloring strings,
                       for function's state, etc.

1.car cdr setcar setcdr cons nthcdr

car:  return the first item in the list
exp:  (car '(rose violet daisy buttercup))  ⇒  rose

cdr:  return the second to last elements
exp:  (cdr '(rose violet daisy buttercup))  ⇒  (violet daisy buttercup)  

setcar: replace the first element in the list and return the replacing element
setcdr: replace the rest of elements in the list and return the replacing element

cons: create a new cons, give it CAR and CDR as components, and return it
exp:  (cons 'rose '(violet daisy buttercup))  ⇒ (rose violet daisy buttercup)

nthcdr: return the nth to last elements
exp:  (nthcdr 1 '(rose violet daisy buttercup)) ⇒ (violet daisy buttercup)

2.interactive
description: the purpose of (interactive …) is to makes your function callable as interactive command,
which can be called by execute-extended-command "M-x".
it also provides a method for taking user input and feed to your function's arguments.

3.quote
description: return the argument, without evaluating it.
exp:  `(quote x)' ⇒ `x'

4.evaluate expression
description: means executing the expression and returning the evaluated result.
exp:  eval-buffer eval-region eval-minibuffer.
rules:  
4.1 self-evaluating:  any form that is not a list or symbol will evaluate to themselves.
4.2 symbol: symbol is treated as a variable and will evaluate to the variable's value.
4.3 list: if the first element of the list is
          a symbol ⇒  uses the symbol's function cell contents, then call the function.
          a function object ⇒  evaluate the remaining elements of the list as actual argument,                       
                                then call the function with this list of arguments.
          a macro object  ⇒  expand the macro to some kind of other form.

5.atom
description: return t if OBJECT is not a cons cell.
exp:  (atom 'a) ⇒ t 

6.mapcar mapc
mapcar: apply FUNCTION to each element of SEQUENCE, and make a list of the results.
exp:  (mapcar '1+ [3 4 5] ) ⇒ (4 5 6)

mapc: apply FUNCTION to each element of SEQUENCE, and return the unchanged SEQUENCE.
exp:  (mapc '1+ [3 4 5] ) ⇒ [3 4 5]

7.push pop nbutlast nth butlast

push: add new element to the list and return the resultant list.
pop:  remove first element from the list and return the removed element.
nbutlast: remove last n elements from the list and return the resultant list.
nth:  return the nth item in the list.
butlast:  return list without the last n elements.

8.alist & hash table
alist:  when a list has the form ((key1 . value1) (key2 . value2) (key3 . value3)), 
        it is called an association list, or alist for short, 
        it is used to records a mapping from keys to values.
exp:  
((red . "ff000") (green . "00ff00") (blue . "000ff"))
((red "ff0000") (green "00ff00O") (blue "000ff")) 
(assoc 'green '((red . "ff000") (green . "00ff00") (blue . "000ff"))) ⇒ (green . "00ff00")

hash table: a very fast kind of lookup table.

9.thing-at-point & bounds-of-thing-at-point
thing-at-point: return the thing at point. 
thing should be a symbol specifying a type of syntactic entity,
including `symbol', `list', `sexp', `defun',`filename', `url', `email', `word', 
`sentence', `whitespace', `line', `number', and `page'.
exp:  (thing-at-point 'word)

bounds-of-thing-at-point: return the start and end buffer locations for the thing at point.
exp:  (bounds-of-thing-at-point 'word)

10.eq equal
eq:  tests whether its arguments are the same object.
equal:  tests whether two objects have the same structure and contents.

11.control structures
11.1 (if COND THEN ELSE...) ⇒ If COND yields non-nil, do THEN, else do ELSE...

11.2 (cond CLAUSES...) ⇒ try each clause until one succeeds.
exp:  
(cond ((eq 'a 'b) 'first) ((atom 'a) 'second)) ⇒ second

11.3 (when COND BODY...) ⇒ If COND yields non-nil, do BODY, else return nil.

11.4 (unless COND BODY...) ⇒ If COND yields nil, do BODY, else return nil.

11.5 (while TEST BODY...) ⇒ If TEST yields non-nil, eval BODY... and repeat.

11.6 (dolist (VAR LIST [RESULT]) BODY...)
     Loop over a list.
     Evaluate BODY with VAR bound to each car from LIST, in turn.
exp:
(dolist (x '(1 2 3)) (insert (number-to-string x))) ⇒ "123"
     
11.7 (dotimes (VAR COUNT [RESULT]) BODY...)
     Loop a certain number of times.
     Evaluate BODY with VAR bound to successive integers running from 0, inclusive, to COUNT, exclusive. 
exp:
(dotimes (x 3 "return value") (insert (number-to-string x))) ⇒ 012"return value"

11.8 catch and throw
     (catch TAG BODY...) ⇒ catch establishes a return point for the throw function.
     (throw TAG VALUE) ⇒ The purpose of throw is to return from a return point previously established with catch.
exp:
(catch 'hack (throw 'hack 'yes)) ⇒ yes
     
12.lambda expression
lambda: return a lambda expression (anonymous function),
        pretty like "anonymous functor" returned by boost::bind() in C++ I think.
exp:
(progn 
  (fset 'sayHello (lambda () (message "Hello World !")))
  (symbol-function 'sayHello) => (lambda () (message "Hello World !"))
  (sayHello)) ⇒ "Hello World !"

13.
