learning assembly

0.汇编指令是机器指令的助记符,同机器指令一一对应.

1.CPU访问内存单元时,要给出内存单元的地址,所有的内存单元构成的存储空间是一个一维的线性空间,
  每一个内存单元在这个空间都有一个唯一的地址,这个地址就是物理地址.

2.物理地址 = 段地址＊16 + 偏移地址.

3.数据不可直接送入段寄存器(CS、DS、...),必须通过普通寄存器(AX、BX、CX、DX)进行中转.

4.CS存放指令的段地址,IP存放指令的偏移地址,8086机中,任意时刻,CPU将CS:IP指向的内容当作指令执行.

5.8086中内存地址由段地址和偏移地址组成,DS寄存器存放要访问数据的段地址,偏移地址由指令给出.
exp:
mov bx, 1000H
mov ds, bx ⇒ 将bx的值传入ds
mov al, [0] ⇒ 内存单元的偏移地址为0,8086自动取ds中的数据为内存单元的段地址
mov al, [bx] ⇒ 内存单元的偏移地址为bx的值,段地址取ds的值
mov al, [bx+100] ⇒ 内存单元的偏移地址为bx+100,段地址取ds的值
mov al, [bx+si]
mov al, [bx+si+100]

6.8086提供了栈操作机制:
  在SS、SP中分别存放栈顶的段地址和偏移地址
  提供入栈和出栈的指令,它们根据SS:SP指示的地址,按照栈的方式访问内存单元.

7.段前缀的使用.
exp:
mov es:[bx], dl ⇒ 将dl的数据传入段地址为es,偏移地址为bx所指向的内存单元中.

8.push、pop指令的执行步骤.
  push  ⇒ (1) SP = SP-2; (2) 向SS:SP指向的字单元中传入数据
  pop   ⇒ (1) 从SS:SP指向的字单元中读取数据 (2) SP = SP + 2;

9.编程时要合理安排栈空间大小,防止入栈数据太多导致overflow,或栈空时继续出栈导致underflow.

10.Loop指令的执行步骤.
  (1) cx = cx-1; 
  (2) 判断cx的值,不为0则转至标号处执行程序,如果为0则向下执行
  
11.and ⇒ 按位与、or ⇒ 按位或 指令.

12.程序中经常需要进行数据的暂存,这些数据可能在内存中,也可能在寄存器中,想要将数据都存在寄存器中是
   不现实的,因为寄存器的数量是有限的;所以一般来说,在需要暂存数据的时候,我们都应该使用栈. 

13.只有bx、si、di、bp这四个寄存器可以用在[...]中进行内存单元的寻址.

14.只要在[...]中使用了寄存器bp,而指令中没有显性地给出段地址,段地址就默认在ss中.

15.如何获取指令处理的数据的长度.
   (1) 通过寄存器名称指明要处理的数据的长度
   exp: 
   mov ax, 1 ⇒ ax 占用一个字单元
   
   (2) X ptr ⇒ word ptr、byte ptr
   exp:
   mov word ptr ds:[0], 1
   
   (3)有些指令默认了访问的是字单元还是字节单元
   exp:
   push [1000H] ⇒ push指令只进行字操作 
   
16.div 是除法指令、mul 是乘法指令.

17.db、dw、dd 分别用于定义字节型、字型、双字型数据,同时分配内存空间.

18.dup 用于和 db、dw、dd 等数据定义伪指令配合,用于定义多个数据.

19.offset 用于取得标号的偏移地址.
exp:
start:  mov ax, offset start  ⇒ start 标记的是代码段中的第一条指令,偏移地址为0
    s:  mov ax, offset s      ⇒ s 标记的是代码段中第二条指令,第一条指令的长度为3字节,所以s的偏移地址为3
    
20.jmp 无条件跳转指令(高级语言中的 goto 语句),既可以只修改IP,也可以同时修改CS和IP.

21.jcxz 有条件跳转指令(高级语言中的 if 语句).
exp:
jcxz 标号 ⇒ 如果 cx=0, 则跳转到标号处执行,否则程序继续往下执行.

22.ret、retf 指令
   ret用栈中数据修改IP的内容,从而实现近跳转
   ⇒ pop IP

   retf用栈中数据修改CS和IP的内容,从而实现远跳转 
   ⇒ pop IP 
     pop CS
    
23.call 指令执行时,将当前IP或CS和IP压入栈中,执行跳转.
exp:
call 标号.
⇒ push IP
  jmp near ptr 标号
  
call far ptr 标号.
⇒ push CS
  push IP
  jmp far ptr 标号
  
  ...
  
24.call与ret配合使用,即可实现调用子程序的机制(高级语言中的函数调用).

25.cdecl、stdcall、fastcall 函数调用约定的区别.
cdecl ⇒ (1) 参数从右向左压入栈 (2) 调用者负责清理栈
stdcall ⇒ (1) 参数从右向左压入栈 (2) 函数自身负责清理栈
fastcall ⇒ (1) 第一和第二个DWORD(或尺寸更小的)参数使用ecx和edx存储,其他参数从右向左压入栈 (2) 函数自身负责清理栈

26.8086CPU的 flag寄存器 每一位都有专门的含义,记录特定的信息.

27.
